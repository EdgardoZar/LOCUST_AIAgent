pipeline {
    agent any
    
    parameters {
        // Script generation parameters
        string(name: 'SCENARIO_NAME', defaultValue: '', description: 'Name of the test scenario')
        text(name: 'SCENARIO_JSON', defaultValue: '', description: 'JSON configuration for the scenario')
        string(name: 'TARGET_HOST', defaultValue: 'https://api.example.com', description: 'Target host URL for testing')
        string(name: 'API_TOKEN', defaultValue: '', description: 'API token for authentication (optional)')
        choice(name: 'ENVIRONMENT', choices: ['dev', 'staging', 'prod'], description: 'Target environment')
        
        // Test configuration (for script generation)
        string(name: 'USERS', defaultValue: '10', description: 'Number of concurrent users')
        string(name: 'SPAWN_RATE', defaultValue: '2', description: 'User spawn rate per second')
        string(name: 'RUN_TIME', defaultValue: '5m', description: 'Test duration (e.g., 5m, 10m, 1h)')
        string(name: 'MIN_WAIT', defaultValue: '1000', description: 'Minimum wait time between requests (ms)')
        string(name: 'MAX_WAIT', defaultValue: '5000', description: 'Maximum wait time between requests (ms)')
        
        // Advanced options
        booleanParam(name: 'GENERATE_HTML_REPORT', defaultValue: true, description: 'Generate HTML test report')
        booleanParam(name: 'GENERATE_CSV_REPORT', defaultValue: true, description: 'Generate CSV test report')
        string(name: 'LOG_LEVEL', defaultValue: 'INFO', description: 'Logging level (DEBUG, INFO, WARNING, ERROR)')
        
        // Git configuration
        string(name: 'GIT_COMMIT_MESSAGE', defaultValue: '', description: 'Custom commit message (optional)')
    }
    
    environment {
        // Python and workspace configuration
        PYTHON_VERSION = "${env.PYTHON_VERSION ?: '3.9'}"
        WORKSPACE_DIR = "${WORKSPACE}\\test_workspace"
        REPORTS_DIR = "${WORKSPACE}\\test_reports"
        SCRIPTS_DIR = "${WORKSPACE}\\generated_scripts"
        TIMESTAMP = "${new Date().format('yyyyMMdd_HHmmss')}"
        
        // Git configuration
        GIT_SCRIPTS_BRANCH = "${env.GIT_SCRIPTS_BRANCH ?: 'generated-scripts'}"
        GIT_SCRIPTS_FOLDER = 'test_workspace/generated_scripts'
        GIT_EMAIL = "${env.JENKINS_GIT_EMAIL ?: 'jenkins@example.com'}"
        GIT_USER = "${env.JENKINS_GIT_USER ?: 'Jenkins Pipeline'}"
        
        // Build information
        BUILD_INFO = "Build #${env.BUILD_NUMBER} - ${env.BUILD_ID}"
        JOB_NAME = "${env.JOB_NAME}"
        BUILD_URL = "${env.BUILD_URL}"
        
        // Environment-specific settings
        ENV_SUFFIX = "${params.ENVIRONMENT == 'prod' ? '' : '_' + params.ENVIRONMENT}"
    }
    
    stages {
        stage('Cleanup Workspace') {
            steps {
                script {
                    echo "Cleaning up workspace to ensure fresh start..."
                    
                    // Remove any existing generated files
                    bat """
                        if exist "${WORKSPACE_DIR}\\generate_script.py" del "${WORKSPACE_DIR}\\generate_script.py"
                        if exist "${WORKSPACE_DIR}\\scenario_config.json" del "${WORKSPACE_DIR}\\scenario_config.json"
                        if exist "${WORKSPACE_DIR}\\test_config.json" del "${WORKSPACE_DIR}\\test_config.json"
                        if exist "${WORKSPACE_DIR}\\generation_metadata.json" del "${WORKSPACE_DIR}\\generation_metadata.json"
                    """
                    
                    echo "Workspace cleanup completed"
                }
            }
        }
        
        stage('Checkout') {
            steps {
                checkout scm
                script {
                    echo "=== Script Generation Pipeline ==="
                    echo "Build Number: ${env.BUILD_NUMBER}"
                    echo "Job Name: ${env.JOB_NAME}"
                    echo "Workspace: ${WORKSPACE}"
                    echo "Branch: ${env.BRANCH_NAME}"
                    echo "Scenario Name: ${params.SCENARIO_NAME}"
                    echo "Environment: ${params.ENVIRONMENT}"
                    echo "Target Host: ${params.TARGET_HOST}"
                }
            }
        }
        
        stage('Setup Environment') {
            steps {
                script {
                    echo "Setting up environment..."
                    echo "Python Version: ${PYTHON_VERSION}"
                    echo "Scripts Branch: ${GIT_SCRIPTS_BRANCH}"
                    echo "Git User: ${GIT_USER}"
                    echo "Git Email: ${GIT_EMAIL}"
                    
                    // Create directories
                    bat "if not exist \"${WORKSPACE_DIR}\" mkdir \"${WORKSPACE_DIR}\""
                    bat "if not exist \"${REPORTS_DIR}\" mkdir \"${REPORTS_DIR}\""
                    bat "if not exist \"${SCRIPTS_DIR}\" mkdir \"${SCRIPTS_DIR}\""
                    
                    // Setup Python virtual environment
                    bat """
                        if not exist venv (
                            python -m venv venv
                        )
                        call venv\\Scripts\\activate.bat
                        pip install --upgrade pip
                        pip install -r requirements.txt
                        pip install -e .
                    """
                }
            }
        }
        
        stage('Validate Input') {
            steps {
                script {
                    echo "Validating input parameters..."
                    
                    if (!params.SCENARIO_NAME?.trim()) {
                        error "SCENARIO_NAME is required"
                    }
                    if (!params.SCENARIO_JSON?.trim()) {
                        error "SCENARIO_JSON is required"
                    }
                    
                    // Store scenario info in environment without parsing JSON
                    env.SCENARIO_NAME = params.SCENARIO_NAME
                    env.SCENARIO_JSON = params.SCENARIO_JSON
                    env.SCENARIO_STEPS_COUNT = "5" // Default, will be updated by Python
                    env.SCENARIO_DESCRIPTION = "Validated by Python"
                    
                    echo "Input validation successful"
                    echo "Scenario name: ${env.SCENARIO_NAME}"
                    echo "JSON length: ${params.SCENARIO_JSON.length()} characters"
                }
            }
        }
        
        stage('Generate Script') {
            steps {
                script {
                    echo "Generating script from scenario configuration..."
                    echo "Environment: ${params.ENVIRONMENT}"
                    echo "Target Host: ${params.TARGET_HOST}"
                    
                    // Write scenario JSON to file directly
                    writeFile file: "${WORKSPACE_DIR}\\scenario_config.json", text: params.SCENARIO_JSON
                    
                    // Create test configuration as JSON string
                    def testConfigJson = groovy.json.JsonOutput.toJson([
                        scenario_name: params.SCENARIO_NAME + ENV_SUFFIX,
                        host: params.TARGET_HOST,
                        users: params.USERS,
                        spawn_rate: params.SPAWN_RATE,
                        run_time: params.RUN_TIME,
                        min_wait: params.MIN_WAIT,
                        max_wait: params.MAX_WAIT,
                        assertions: [
                            [type: "status_code", value: 200]
                        ],
                        extract_variables: [:],
                        headers: [
                            "Content-Type": "application/json",
                            "User-Agent": "Jenkins-Locust-AI-Agent/1.0"
                        ],
                        params: [:],
                        body: [:],
                        output_dir: REPORTS_DIR,
                        generate_csv: params.GENERATE_CSV_REPORT,
                        generate_html: params.GENERATE_HTML_REPORT,
                        log_level: params.LOG_LEVEL
                    ])
                    
                    writeFile file: "${WORKSPACE_DIR}\\test_config.json", text: testConfigJson
                    
                    // Write the Python script to a file
                    def pyScript = """
import sys
import json
import os
import subprocess
import time
import logging
from datetime import datetime
from typing import Dict, List, Optional, Any
from pathlib import Path
from dataclasses import dataclass, asdict

# Get paths from command line arguments
if len(sys.argv) < 3:
    print("Usage: python script.py <workspace> <workspace_dir>")
    sys.exit(1)

workspace = sys.argv[1]
workspace_dir = sys.argv[2]

# Include the necessary classes directly to avoid import issues
@dataclass
class TestConfig:
    scenario_name: str
    host: str
    users: int = 1
    spawn_rate: int = 1
    run_time: str = "1m"
    min_wait: int = 1000
    max_wait: int = 5000
    assertions: List[Dict] = None
    extract_variables: Dict[str, str] = None
    headers: Dict[str, str] = None
    params: Dict[str, str] = None
    body: Dict[str, Any] = None
    output_dir: str = "test_reports"
    generate_csv: bool = True
    generate_html: bool = True
    log_level: str = "INFO"

    def __post_init__(self):
        if self.assertions is None:
            self.assertions = []
        if self.extract_variables is None:
            self.extract_variables = {}
        if self.headers is None:
            self.headers = {}
        if self.params is None:
            self.params = {}

class LocustTestAgent:
    def __init__(self, workspace_dir: str = None):
        self.workspace_dir = workspace_dir or os.getcwd()
        self.scripts_dir = os.path.join(self.workspace_dir, "generated_scripts")
        self.reports_dir = os.path.join(self.workspace_dir, "generated_reports")
        
        os.makedirs(self.scripts_dir, exist_ok=True)
        os.makedirs(self.reports_dir, exist_ok=True)
        
        logging.basicConfig(level=logging.INFO)
        self.logger = logging.getLogger(__name__)
    
    def generate_script(self, scenario: Dict[str, Any], config: TestConfig) -> str:
        try:
            script_content = self._generate_basic_script(scenario, config)
            
            safe_name = ''.join(c if c.isalnum() or c in ('-', '_') else '_' for c in scenario["name"])
            script_filename = f"{safe_name}.py"
            script_path = os.path.join(self.scripts_dir, script_filename)
            
            with open(script_path, 'w') as f:
                f.write(script_content)
            
            self.logger.info(f"Generated script: {script_path}")
            return script_path
            
        except Exception as e:
            raise RuntimeError(f"Error generating script: {e}")
    
    def _generate_basic_script(self, scenario: Dict[str, Any], config: TestConfig) -> str:
        class_name = self._class_name_from_scenario(scenario['name'])
        
        script_lines = [
            "from locust import HttpUser, task, between",
            "import json",
            "import time",
            "import logging",
            "",
            f"class {class_name}User(HttpUser):",
            f"    wait_time = between({config.min_wait/1000}, {config.max_wait/1000})",
            "",
            "    def on_start(self):",
            "        self.variables = {}",
            "        self.logger = logging.getLogger(__name__)",
            "",
            "    def extract_variables(self, response, extract_config):",
            "        if not extract_config:",
            "            return",
            "        try:",
            "            data = response.json()",
            "            for var_name, json_path in extract_config.items():",
            "                try:",
            "                    parts = json_path.split('.')",
            "                    value = data",
            "                    for part in parts:",
            "                        if isinstance(value, dict):",
            "                            value = value.get(part)",
            "                        else:",
            "                            value = None",
            "                            break",
            "                    if value is not None:",
            "                        self.variables[var_name] = str(value)",
            "                        self.logger.info(f'Extracted {var_name} = {value}')",
            "                except Exception as e:",
            "                    self.logger.error(f'Error extracting {var_name}: {str(e)}')",
            "        except Exception as e:",
            "            self.logger.error(f'Error parsing response JSON: {str(e)}')",
            "",
            "    def replace_variables(self, text):",
            "        if not self.variables:",
            "            return text",
            "        for var_name, value in self.variables.items():",
            "            text = text.replace(f'{{{{{var_name}}}}}', str(value))",
            "        return text",
            ""
        ]
        
        # Add tasks for each step
        for i, step in enumerate(scenario.get("steps", [])):
            method_name = step.get("name", f"step_{i+1}").replace(" ", "_").replace("-", "_")
            url = step.get("url", "/")
            method = step.get("method", "GET").upper()
            headers = step.get("headers", {})
            params = step.get("params", {})
            body = step.get("body", {})
            extract_vars = step.get("extract_variables", {})
            assertions = step.get("assertions", [])
            
            script_lines.extend([
                f"    @task",
                f"    def {method_name}(self):",
                f"        url = self.replace_variables('{url}')",
            ])
            
            if headers:
                script_lines.append(f"        headers = {json.dumps(headers)}")
            else:
                script_lines.append("        headers = {}")
            
            if params:
                script_lines.append(f"        params = {json.dumps(params)}")
            else:
                script_lines.append("        params = {}")
            
            if body and method in ["POST", "PUT", "PATCH"]:
                script_lines.append(f"        data = {json.dumps(body)}")
                script_lines.append(f"        response = self.client.{method.lower()}(url, json=data, headers=headers, params=params)")
            else:
                script_lines.append(f"        response = self.client.{method.lower()}(url, headers=headers, params=params)")
            
            if extract_vars:
                script_lines.append(f"        self.extract_variables(response, {json.dumps(extract_vars)})")
            
            # Add assertions
            for assertion in assertions:
                assertion_type = assertion.get("type", "status_code")
                expected = assertion.get("expected")
                if assertion_type == "status_code":
                    script_lines.append(f"        assert response.status_code == {expected}, f'Expected status {expected}, got {{response.status_code}}'")
                elif assertion_type == "response_time":
                    script_lines.append(f"        assert response.elapsed.total_seconds() < {expected}, f'Response time {{response.elapsed.total_seconds()}}s exceeded {expected}s'")
            
            script_lines.append("")
        
        return "\\n".join(script_lines)
    
    def _class_name_from_scenario(self, scenario_name: str) -> str:
        return ''.join(word.capitalize() for word in scenario_name.replace('-', ' ').replace('_', ' ').split())

try:
    # Load and validate scenario configuration
    scenario_file = os.path.join(workspace_dir, "scenario_config.json")
    with open(scenario_file, "r") as f:
        scenario_config = json.load(f)
    
    # Load test configuration
    test_config_file = os.path.join(workspace_dir, "test_config.json")
    with open(test_config_file, "r") as f:
        test_config_data = json.load(f)
    
    # Validate scenario structure
    if not scenario_config.get("name"):
        raise ValueError("Scenario name is required")
    if not scenario_config.get("steps"):
        raise ValueError("Scenario steps are required")
    
    steps_count = len(scenario_config.get("steps", []))
    description = scenario_config.get("description", "No description provided")
    
    print(f"Scenario: {scenario_config['name']}")
    print(f"Steps: {steps_count}")
    print(f"Description: {description}")
    
    test_config = TestConfig(**test_config_data)
    agent = LocustTestAgent(workspace_dir=workspace_dir)
    script_path = agent.generate_script(scenario_config, test_config)
    
    print(f"Script generated successfully: {script_path}")
    
    metadata = {
        "script_path": script_path,
        "scenario_name": scenario_config["name"],
        "steps_count": steps_count,
        "description": description,
        "success": True
    }
    
    metadata_file = os.path.join(workspace_dir, "generation_metadata.json")
    with open(metadata_file, "w") as f:
        json.dump(metadata, f, indent=2)
        
except Exception as e:
    print(f"Error: {str(e)}")
    metadata = {
        "success": False,
        "error": str(e)
    }
    metadata_file = os.path.join(workspace_dir, "generation_metadata.json")
    with open(metadata_file, "w") as f:
        json.dump(metadata, f, indent=2)
    sys.exit(1)
"""
                    writeFile file: "${WORKSPACE_DIR}\\generate_script.py", text: pyScript
                    
                    // Run the Python script directly without package installation
                    bat """
                        call venv\\Scripts\\activate.bat
                        cd ${WORKSPACE}
                        set PYTHONPATH=%PYTHONPATH%;%CD%
                        python ${WORKSPACE_DIR}\\generate_script.py "${WORKSPACE}" "${WORKSPACE_DIR}"
                    """
                    
                    // Read generation metadata
                    def metadataText = readFile file: "${WORKSPACE_DIR}\\generation_metadata.json"
                    def metadata = new groovy.json.JsonSlurper().parseText(metadataText)
                    
                    if (metadata.success) {
                        env.GENERATED_SCRIPT = metadata.script_path
                        env.SCENARIO_STEPS_COUNT = metadata.steps_count.toString()
                        env.SCENARIO_DESCRIPTION = metadata.description
                        echo "Generated script: ${env.GENERATED_SCRIPT}"
                        echo "Script generation completed successfully!"
                    } else {
                        error "Script generation failed: ${metadata.error}"
                    }
                }
            }
        }
        
        stage('Save to Git') {
            steps {
                script {
                    echo "Saving generated script to Git..."
                    echo "Branch: ${GIT_SCRIPTS_BRANCH}"
                    echo "Script: ${env.GENERATED_SCRIPT}"
                    
                    // Configure Git
                    bat """
                        git config user.email "${GIT_EMAIL}"
                        git config user.name "${GIT_USER}"
                    """
                    
                    // Create scripts branch if it doesn't exist
                    bat """
                        git checkout -b ${GIT_SCRIPTS_BRANCH} 2>nul || git checkout ${GIT_SCRIPTS_BRANCH}
                    """
                    
                    // Add generated script
                    def commitMessage = params.GIT_COMMIT_MESSAGE ?: "Generated script: ${params.SCENARIO_NAME} - ${TIMESTAMP} - ${BUILD_INFO}"
                    bat """
                        git add ${SCRIPTS_DIR}\\*.py
                        git commit -m "${commitMessage}" || echo "No changes to commit"
                    """
                    
                    // Push to remote
                    bat """
                        git push origin ${GIT_SCRIPTS_BRANCH} || echo "Push failed or no changes"
                    """
                    
                    // Return to main branch
                    bat "git checkout main"
                    
                    echo "Script saved to Git branch: ${GIT_SCRIPTS_BRANCH}"
                    echo "Commit message: ${commitMessage}"
                }
            }
        }
        
        stage('Archive Script') {
            steps {
                script {
                    // Archive the generated script
                    archiveArtifacts artifacts: "${SCRIPTS_DIR}\\*.py", fingerprint: true
                    echo "Script archived successfully: ${env.GENERATED_SCRIPT}"
                }
            }
        }
    }
    
    post {
        always {
            script {
                echo "=== Script Generation Pipeline Summary ==="
                echo "Build Number: ${env.BUILD_NUMBER}"
                echo "Job Name: ${env.JOB_NAME}"
                echo "Result: ${currentBuild.result}"
                echo "Build URL: ${env.BUILD_URL}"
                echo "Generated Script: ${env.GENERATED_SCRIPT}"
                echo "Scripts Branch: ${GIT_SCRIPTS_BRANCH}"
                echo "Environment: ${params.ENVIRONMENT}"
                echo "Scenario Steps: ${env.SCENARIO_STEPS_COUNT}"
            }
        }
        
        success {
            echo "‚úÖ Script generated and saved to Git successfully!"
            echo "üìÅ Script: ${env.GENERATED_SCRIPT}"
            echo "üåø Branch: ${GIT_SCRIPTS_BRANCH}"
            echo "üîó You can now use this script in the Test Execution Pipeline"
        }
        
        failure {
            echo "‚ùå Script generation failed!"
            echo "üìã Check the console output for error details"
            echo "üîß Verify your JSON format and parameters"
        }
        
        unstable {
            echo "‚ö†Ô∏è Script generation completed with warnings"
        }
    }
} 